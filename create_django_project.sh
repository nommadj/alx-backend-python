#!/bin/bash

# Define project and app names
PROJECT_NAME="messaging_app"
APP_NAME="chats"
VENV_DIR=".venv"
ZIP_FILE_NAME="${PROJECT_NAME}_project.zip"

echo "Starting Django project setup and file creation..."

# 1. Create the main project directory and navigate into it
echo "Creating project directory: $PROJECT_NAME"
mkdir -p "$PROJECT_NAME"
cd "$PROJECT_NAME" || { echo "Failed to change directory to $PROJECT_NAME"; exit 1; }

# 2. Create a virtual environment
echo "Creating virtual environment: $VENV_DIR"
python3 -m venv "$VENV_DIR"

# 3. Activate the virtual environment
echo "Activating virtual environment..."
source "$VENV_DIR/bin/activate"

# 4. Install Django and Django REST Framework
echo "Installing Django and Django REST Framework..."
pip install Django djangorestframework django-environ djangorestframework-simplejwt uuid

# 5. Scaffold the Django project
echo "Scaffolding Django project: $PROJECT_NAME"
django-admin startproject "$PROJECT_NAME" .

# 6. Create a new Django app for messaging functionality
echo "Creating Django app: $APP_NAME"
python manage.py startapp "$APP_NAME"

# 7. Configure settings.py (Initial setup for INSTALLED_APPS, REST_FRAMEWORK, and CORS)
echo "Writing content to $PROJECT_NAME/settings.py..."
cat << 'EOF' > "$PROJECT_NAME/settings.py"
"""
Django settings for messaging_app project.

Generated by 'django-admin startproject' using Django 5.0.7.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""

from pathlib import Path
import os
import environ

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Load environment variables
env = environ.Env(
    DEBUG=(bool, False)
)
environ.Env.read_env(os.path.join(BASE_DIR, '.env'))

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = env('SECRET_KEY')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = env('DEBUG')

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'rest_framework_simplejwt',
    'chats', # Your newly created app
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'messaging_app.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
    },
]

WSGI_APPLICATION = 'messaging_app.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.0/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Django REST Framework settings
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',
    ),
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,
}

# Custom User Model
AUTH_USER_MODEL = 'chats.User'

EOF

# Create an .env file for environment variables
echo "Creating .env file..."
cat << 'EOF' > .env
SECRET_KEY=your_secret_key_here_generate_a_strong_one
DEBUG=True
EOF
echo "Remember to replace 'your_secret_key_here_generate_a_strong_one' in .env with a strong secret key."
echo "You can generate one using: python -c 'from django.core.management.utils import get_random_secret_key; print(get_random_secret_key())'"

# 8. Define Data Models (messaging_app/chats/models.py)
echo "Writing content to $APP_NAME/models.py..."
cat << 'EOF' > "$APP_NAME/models.py"
import uuid
from django.db import models
from django.contrib.auth.models import AbstractUser, BaseUserManager

class CustomUserManager(BaseUserManager):
    """
    Custom user model manager where email is the unique identifiers
    for authentication instead of usernames.
    """
    def create_user(self, email, password=None, **extra_fields):
        if not email:
            raise ValueError('The Email must be set')
        email = self.normalize_email(email)
        user = self.model(email=email, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, email, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)
        extra_fields.setdefault('is_active', True)
        extra_fields.setdefault('role', 'admin') # Set admin role for superuser

        if extra_fields.get('is_staff') is not True:
            raise ValueError('Superuser must have is_staff=True.')
        if extra_fields.get('is_superuser') is not True:
            raise ValueError('Superuser must have is_superuser=True.')
        return self.create_user(email, password, **extra_fields)

class User(AbstractUser):
    """
    Custom User model extending Django's AbstractUser to include
    additional fields like phone_number and role, and using UUID as PK.
    """
    class Role(models.TextChoices):
        GUEST = 'guest', 'Guest'
        HOST = 'host', 'Host'
        ADMIN = 'admin', 'Admin'

    user_id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False, unique=True)
    first_name = models.CharField(max_length=100, null=False, blank=False)
    last_name = models.CharField(max_length=100, null=False, blank=False)
    email = models.EmailField(unique=True, null=False, blank=False)
    # password_hash is handled by Django's built-in password field
    phone_number = models.CharField(max_length=20, null=True, blank=True)
    role = models.CharField(max_length=10, choices=Role.choices, default=Role.GUEST, null=False, blank=False)
    created_at = models.DateTimeField(auto_now_add=True)

    # Use email as the USERNAME_FIELD
    USERNAME_FIELD = 'email'
    # Remove 'username' from REQUIRED_FIELDS if it's there from AbstractUser default
    REQUIRED_FIELDS = ['first_name', 'last_name'] # These fields will be prompted when creating a superuser

    objects = CustomUserManager()

    def __str__(self):
        return self.email

class Conversation(models.Model):
    """
    Model to track conversations between users.
    A conversation can have multiple participants (users).
    """
    conversation_id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False, unique=True)
    participants = models.ManyToManyField(User, related_name='conversations')
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        # List participants' emails for easy identification
        return f"Conversation {self.conversation_id} with participants: {', '.join([p.email for p in self.participants.all()])}"

class Message(models.Model):
    """
    Model to store individual messages within a conversation.
    """
    message_id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False, unique=True)
    conversation = models.ForeignKey(Conversation, on_delete=models.CASCADE, related_name='messages')
    sender = models.ForeignKey(User, on_delete=models.CASCADE, related_name='sent_messages')
    message_body = models.TextField(null=False, blank=False)
    sent_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Message from {self.sender.email} in Conversation {self.conversation.conversation_id}"

    class Meta:
        ordering = ['sent_at'] # Order messages by time sent
EOF

# 9. Create Serializers (messaging_app/chats/serializers.py)
echo "Writing content to $APP_NAME/serializers.py..."
cat << 'EOF' > "$APP_NAME/serializers.py"
from rest_framework import serializers
from .models import User, Conversation, Message

class UserSerializer(serializers.ModelSerializer):
    """
    Serializer for the Custom User model.
    Excludes sensitive fields like password.
    """
    class Meta:
        model = User
        fields = (
            'user_id', 'first_name', 'last_name', 'email', 'phone_number',
            'role', 'created_at'
        )
        read_only_fields = ('user_id', 'created_at')

class MessageSerializer(serializers.ModelSerializer):
    """
    Serializer for the Message model.
    Includes sender information nested.
    """
    sender_details = UserSerializer(source='sender', read_only=True) # Nested serializer for sender

    class Meta:
        model = Message
        fields = (
            'message_id', 'conversation', 'sender', 'sender_details',
            'message_body', 'sent_at'
        )
        read_only_fields = ('message_id', 'sent_at', 'sender_details')
        extra_kwargs = {'sender': {'write_only': True}} # Make sender write-only for creation

class ConversationSerializer(serializers.ModelSerializer):
    """
    Serializer for the Conversation model.
    Includes nested messages and participants.
    """
    participants = UserSerializer(many=True, read_only=True) # Nested serializer for participants
    messages = MessageSerializer(many=True, read_only=True) # Nested serializer for messages

    class Meta:
        model = Conversation
        fields = (
            'conversation_id', 'participants', 'messages', 'created_at'
        )
        read_only_fields = ('conversation_id', 'created_at')

    def create(self, validated_data):
        """
        Handle creation of a conversation with participants.
        Expects 'participant_ids' in initial_data if creating a new conversation.
        """
        # We need to get participant_ids from the request's initial_data
        # since participants is a ManyToManyField and read-only on the serializer
        participant_ids = self.context.get('request').data.get('participant_ids', [])
        if not participant_ids:
            raise serializers.ValidationError({"participant_ids": "At least one participant ID is required to create a conversation."})

        conversation = Conversation.objects.create(**validated_data)
        # Add participants to the conversation
        users = User.objects.filter(user_id__in=participant_ids)
        if not users.exists():
            raise serializers.ValidationError({"participant_ids": "No valid participants found for the provided IDs."})
        conversation.participants.set(users) # Use .set() for ManyToManyField
        return conversation
EOF

# 10. Build API Endpoints with Views (messaging_app/chats/views.py)
echo "Writing content to $APP_NAME/views.py..."
cat << 'EOF' > "$APP_NAME/views.py"
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.db.models import Q

from .models import User, Conversation, Message
from .serializers import UserSerializer, ConversationSerializer, MessageSerializer

class UserViewSet(viewsets.ReadOnlyModelViewSet):
    """
    A simple ViewSet for viewing users.
    Only allows authenticated users to list and retrieve themselves or other users.
    """
    queryset = User.objects.all()
    serializer_class = UserSerializer
    permission_classes = [IsAuthenticated]

    # Optionally, restrict users to only view their own profile or allow admins to view all
    def get_queryset(self):
        if self.request.user.is_superuser:
            return User.objects.all()
        return User.objects.filter(user_id=self.request.user.user_id)


class ConversationViewSet(viewsets.ModelViewSet):
    """
    A ViewSet for viewing and editing conversations.
    Users can only see/manage conversations they are a part of.
    """
    serializer_class = ConversationSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        """
        Filter conversations to only show those where the requesting user is a participant.
        """
        user = self.request.user
        return Conversation.objects.filter(participants=user).distinct()

    def perform_create(self, serializer):
        """
        When creating a conversation, ensure the current user is a participant.
        The `create` method in the serializer handles adding other participants.
        """
        # We need to modify the request data to include the current user as a participant
        # since the 'participants' field is read_only in the serializer.
        request_data = self.request.data.copy()
        current_user_id = str(self.request.user.user_id)

        if 'participant_ids' not in request_data:
            request_data['participant_ids'] = []

        if current_user_id not in request_data['participant_ids']:
            request_data['participant_ids'].append(current_user_id)

        # Pass the modified request data to the serializer's create method via context
        serializer.context['request'] = self.request
        serializer.context['request'].data.update(request_data) # Update original request data for serializer validation

        serializer.is_valid(raise_exception=True)
        self.object = serializer.save()


    @action(detail=True, methods=['post'])
    def send_message(self, request, pk=None):
        """
        Custom action to send a message within a specific conversation.
        """
        conversation = self.get_object() # Ensures the user has access to this conversation

        # Check if the requesting user is a participant of this conversation
        if not conversation.participants.filter(user_id=request.user.user_id).exists():
            return Response(
                {"detail": "You are not a participant of this conversation."},
                status=status.HTTP_403_FORBIDDEN
            )

        serializer = MessageSerializer(data=request.data)
        if serializer.is_valid():
            # Automatically set the sender and conversation
            serializer.save(sender=request.user, conversation=conversation)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

class MessageViewSet(viewsets.ModelViewSet):
    """
    A ViewSet for viewing and creating messages.
    Users can only see messages in conversations they are a part of.
    """
    serializer_class = MessageSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        """
        Filter messages to only show those belonging to conversations
        where the requesting user is a participant.
        """
        user = self.request.user
        return Message.objects.filter(
            conversation__participants=user
        ).distinct().order_by('sent_at')

    def perform_create(self, serializer):
        """
        When creating a message, ensure the sender is the current user
        and they are a participant of the target conversation.
        """
        conversation_id = self.request.data.get('conversation')
        if not conversation_id:
            return Response(
                {"conversation": "This field is required."},
                status=status.HTTP_400_BAD_REQUEST
            )

        try:
            conversation = Conversation.objects.get(conversation_id=conversation_id)
        except Conversation.DoesNotExist:
            return Response(
                {"conversation": "Conversation not found."},
                status=status.HTTP_404_NOT_FOUND
            )

        # Ensure the current user is a participant of the conversation they are sending a message to
        if not conversation.participants.filter(user_id=self.request.user.user_id).exists():
            return Response(
                {"detail": "You are not a participant of this conversation."},
                status=status.HTTP_403_FORBIDDEN
            )

        serializer.save(sender=self.request.user, conversation=conversation)
EOF

# 11. Set up URL Routing for the chats app (messaging_app/chats/urls.py)
echo "Writing content to $APP_NAME/urls.py..."
cat << 'EOF' > "$APP_NAME/urls.py"
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import UserViewSet, ConversationViewSet, MessageViewSet

router = DefaultRouter()
router.register(r'users', UserViewSet, basename='user')
router.register(r'conversations', ConversationViewSet, basename='conversation')
router.register(r'messages', MessageViewSet, basename='message')

urlpatterns = [
    path('', include(router.urls)),
]
EOF

# 12. Update main project's urls.py (messaging_app/messaging_app/urls.py)
echo "Updating content in $PROJECT_NAME/urls.py..."
cat << 'EOF' > "$PROJECT_NAME/urls.py"
from django.contrib import admin
from django.urls import path, include
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)

urlpatterns = [
    path('admin/', admin.site.urls),
    # Include API routes from your chats app under /api/
    path('api/', include('chats.urls')),
    # JWT Authentication Endpoints
    path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
]
EOF

# 13. Run initial migrations
echo "Running initial migrations..."
# Deactivate and reactivate to ensure all new settings/paths are recognized
deactivate
source "$VENV_DIR/bin/activate"
python manage.py makemigrations "$APP_NAME"
python manage.py migrate

echo "Project setup and file creation complete. Your Django project is ready."
echo "You can now create a superuser and run the development server:"
echo "  python manage.py createsuperuser"
echo "  python manage.py runserver"
echo ""

# 14. Create a zip archive of the project
echo "Creating a zip archive of the '$PROJECT_NAME' project..."
# Go up one level to zip the entire project directory
cd ..
zip -r "$ZIP_FILE_NAME" "$PROJECT_NAME" -x "$PROJECT_NAME/$VENV_DIR/*"

echo "Zip file created: $ZIP_FILE_NAME"
echo "To clean up the project directory after zipping, you can run: rm -rf $PROJECT_NAME"
echo "To deactivate the virtual environment, if still active, use: deactivate"l